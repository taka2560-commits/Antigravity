import { useState, useEffect, useMemo } from "react"
import { useLiveQuery } from "dexie-react-hooks"
import { db, type LevelingSession, type LevelingRow } from "../db"
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "./ui/card"
import { Button } from "./ui/button"
import { Input } from "./ui/input"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "./ui/table"
import { Plus, Trash2, Save, FolderOpen, ArrowLeft, Download, FileText } from "lucide-react"
import { generateLevelingBookPDF } from "../utils/reports/levelingBook"


export function LevelingBook() {
    const [view, setView] = useState<"list" | "edit">("list")
    const [currentSessionId, setCurrentSessionId] = useState<number | null>(null)
    const [rows, setRows] = useState<LevelingRow[]>([])
    const [sessionMeta, setSessionMeta] = useState({ name: "", note: "" })

    const sessions = useLiveQuery(() => db.levelings.orderBy('updatedAt').reverse().toArray())

    // Load session
    useEffect(() => {
        if (currentSessionId && sessions) {
            const session = sessions.find(s => s.id === currentSessionId)
            if (session) {
                setRows(session.rows || [])
                setSessionMeta({ name: session.name, note: session.note })
            }
        }
    }, [currentSessionId, sessions])

    const handleCreateNew = () => {
        setRows([
            { id: crypto.randomUUID(), no: "No.1", note: "BM.1", isManualGH: true, gh: 0 }
        ])
        setSessionMeta({ name: `観測-${new Date().toLocaleDateString()}`, note: "" })
        setCurrentSessionId(null)
        setView("edit")
    }

    const handleEditSession = (id: number) => {
        setCurrentSessionId(id)
        setView("edit")
    }

    const handleDeleteSession = async (id: number, e: React.MouseEvent) => {
        e.stopPropagation()
        if (confirm("この観測データを削除しますか？")) {
            await db.levelings.delete(id)
            if (currentSessionId === id) {
                setView("list")
                setCurrentSessionId(null)
            }
        }
    }

    const handleBack = () => {
        setView("list")
        setCurrentSessionId(null)
    }

    // --- Calculation Logic ---
    const calculatedRows = useMemo(() => {
        let currentIH: number | null = null;
        let lastGH: number | null = null;

        return rows.map((row, _index) => {
            const r = { ...row };

            // Start Point or Manual GH override
            if (r.isManualGH && r.gh !== undefined && !isNaN(r.gh)) {
                lastGH = r.gh;
            } else if (currentIH !== null && r.fs !== undefined && !isNaN(r.fs!)) {
                // Calculate GH from FS
                r.gh = currentIH - r.fs;
                lastGH = r.gh;
            } else {
                r.gh = undefined;
                lastGH = null;
            }

            // Calculate IH if BS exists
            if (r.bs !== undefined && !isNaN(r.bs!) && lastGH !== null) {
                r.ih = lastGH + r.bs;
                currentIH = r.ih;
            } else {
                // If no BS, IH remains (or becomes null if it was a TP where we moved but didn't read BS? No, IH is instrument specific)
                // Actually, if we just read FS, the IH is still valid for other points from same setup.
                // But usually in leveling line, we move after FS.
                // If it's a "Spread" (Intermediate point), IH doesn't change.
                // We assume sequential: BS/FS pairs usually mean TP.
                // If just FS, it's intermediate.
                // If BS is present, it updates IH for *subsequent* readings (which would be invalid unless we moved instrument).
                // Wait, standard:
                // Setup 1: Read BS on Point A. IH = GH_A + BS.
                //          Read FS on Point B. GH_B = IH - FS.
                // If B is TP: Move instrument.
                // Setup 2: Read BS on Point B. IH_new = GH_B + BS_new.

                // So, if a row has BS, it calculates a NEW IH, based on the GH of that row.
                // This IH applies to *subsequent* FS readings.
                // For the *current* row, the GH is either manual (Start) or calc'd from *previous* IH.

                // Logic implemented above:
                // 1. Determine GH of this row (Manual OR prev_IH - FS)
                // 2. Determine IH generated by this row (Item GH + BS) -> becomes current_IH for NEXT row.

                // This looks correct.
                r.ih = undefined; // Don't store IH in input row usually, but for display we might want to show it.
                // We can return the calculated state alongside.

                // Let's store calculated values in the returned object for display
            }

            return {
                ...r,
                calcIH: (r.bs !== undefined && !isNaN(r.bs!) && lastGH !== null) ? lastGH + r.bs : undefined
            };
        });
    }, [rows]);

    const updateRow = (id: string, field: keyof LevelingRow, value: any) => {
        setRows(prev => prev.map(r => {
            if (r.id === id) {
                let newVal = value;
                // Handle numeric conversion
                if (field === 'bs' || field === 'fs' || field === 'gh') {
                    const num = parseFloat(value);
                    newVal = isNaN(num) ? undefined : num;
                }
                return { ...r, [field]: newVal };
            }
            return r;
        }));
    };

    const addRow = () => {
        setRows(prev => [
            ...prev,
            { id: crypto.randomUUID(), no: "", note: "" }
        ]);
    };

    const removeRow = (id: string) => {
        setRows(prev => prev.filter(r => r.id !== id));
    };

    const handleSave = async () => {
        const session: LevelingSession = {
            id: currentSessionId ?? undefined,
            date: new Date().toISOString(),
            name: sessionMeta.name,
            note: sessionMeta.note,
            rows: rows,
            updatedAt: Date.now()
        };

        const id = await db.levelings.put(session);
        setCurrentSessionId(Number(id));
        alert("保存しました");
    };

    const handleExportCSV = () => {
        // Simple CSV export
        const header = "No,BS,IH,FS,GH,Note\n";
        const body = calculatedRows.map(r => {
            return `${r.no},${r.bs ?? ''},${r.calcIH ?? ''},${r.fs ?? ''},${r.gh?.toFixed(4) ?? ''},${r.note}`
        }).join("\n");
        const blob = new Blob([header + body], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `${sessionMeta.name}.csv`;
        link.click();
    };


    if (view === "list") {
        return (
            <Card className="border-0 shadow-none sm:border sm:shadow-sm bg-card">
                <CardHeader className="px-0 pt-0 pb-4 sm:px-6 sm:pt-6">
                    <div className="flex items-center justify-between">
                        <CardTitle className="text-lg font-bold">水準測量 (観測手簿)</CardTitle>
                        <Button onClick={handleCreateNew} size="sm">
                            <Plus className="h-4 w-4 mr-2" /> 新規観測
                        </Button>
                    </div>
                    <CardDescription>
                        水準測量の観測記録を作成・管理します。
                    </CardDescription>
                </CardHeader>
                <CardContent className="px-0 sm:px-6">
                    <div className="space-y-4">
                        {sessions?.map(session => (
                            <div key={session.id}
                                className="flex items-center justify-between p-4 bg-card border rounded-lg hover:bg-muted/50 cursor-pointer transition-colors"
                                onClick={() => handleEditSession(session.id!)}
                            >
                                <div className="space-y-1">
                                    <div className="font-semibold">{session.name}</div>
                                    <div className="text-xs text-muted-foreground flex gap-2">
                                        <span>{new Date(session.updatedAt).toLocaleString()}</span>
                                        <span>•</span>
                                        <span>{session.rows?.length || 0}点</span>
                                    </div>
                                    {session.note && <div className="text-xs text-muted-foreground truncate max-w-[200px]">{session.note}</div>}
                                </div>
                                <div className="flex items-center gap-2">
                                    <Button variant="ghost" size="icon" onClick={() => handleEditSession(session.id!)}>
                                        <FolderOpen className="h-4 w-4 text-primary" />
                                    </Button>
                                    <Button variant="ghost" size="icon" onClick={(e) => handleDeleteSession(session.id!, e)}>
                                        <Trash2 className="h-4 w-4 text-destructive" />
                                    </Button>
                                </div>
                            </div>
                        ))}
                        {(!sessions || sessions.length === 0) && (
                            <div className="text-center py-10 text-muted-foreground text-sm">
                                データがありません
                            </div>
                        )}
                    </div>
                </CardContent>
            </Card>
        )
    }

    // Edit View
    return (
        <Card className="border-0 shadow-none sm:border sm:shadow-sm h-[calc(100vh-200px)] flex flex-col bg-card">
            <CardHeader className="px-0 pt-0 pb-2 sm:px-6 sm:pt-6 flex-none">
                <div className="flex items-center gap-2 mb-2">
                    <Button variant="ghost" size="sm" onClick={handleBack} className="-ml-2">
                        <ArrowLeft className="h-4 w-4 mr-1" /> 一覧へ
                    </Button>
                </div>
                <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4">
                    <div className="flex-1 space-y-2">
                        <Input
                            value={sessionMeta.name}
                            onChange={(e) => setSessionMeta(prev => ({ ...prev, name: e.target.value }))}
                            className="text-lg font-bold h-9"
                            placeholder="観測名"
                        />
                        <Input
                            value={sessionMeta.note}
                            onChange={(e) => setSessionMeta(prev => ({ ...prev, note: e.target.value }))}
                            className="text-xs h-7 text-muted-foreground"
                            placeholder="備考・メモ"
                        />
                    </div>
                    <div className="flex items-center gap-2">
                        <Button variant="outline" size="sm" onClick={handleExportCSV}>
                            <Download className="h-4 w-4 mr-2" /> CSV
                        </Button>
                        <Button variant="outline" size="sm" onClick={() => generateLevelingBookPDF(
                            { ...sessionMeta, rows: [], id: currentSessionId!, date: new Date().toISOString(), updatedAt: Date.now() },
                            calculatedRows
                        )}>
                            <FileText className="h-4 w-4 mr-2" /> PDF
                        </Button>
                        <Button onClick={handleSave} size="sm">
                            <Save className="h-4 w-4 mr-2" /> 保存
                        </Button>
                    </div>
                </div>
            </CardHeader>

            <CardContent className="px-0 sm:px-6 flex-1 overflow-hidden flex flex-col">
                <div className="border rounded-md overflow-auto flex-1 relative">
                    <Table>
                        <TableHeader className="sticky top-0 bg-secondary z-10">
                            <TableRow>
                                <TableHead className="w-[50px]"></TableHead>
                                <TableHead className="min-w-[80px]">測点</TableHead>
                                <TableHead className="min-w-[80px] text-right">後視(BS)</TableHead>
                                <TableHead className="min-w-[80px] text-right bg-muted/50">器械高(IH)</TableHead>
                                <TableHead className="min-w-[80px] text-right">前視(FS)</TableHead>
                                <TableHead className="min-w-[80px] text-right bg-muted/50">地盤高(GH)</TableHead>
                                <TableHead className="min-w-[150px]">備考</TableHead>
                                <TableHead className="w-[50px]"></TableHead>
                            </TableRow>
                        </TableHeader>
                        <TableBody>
                            {calculatedRows.map((row, index) => (
                                <TableRow key={row.id}>
                                    <TableCell className="text-xs text-muted-foreground text-center">
                                        {index + 1}
                                    </TableCell>
                                    <TableCell>
                                        <Input
                                            value={row.no}
                                            onChange={(e) => updateRow(row.id, 'no', e.target.value)}
                                            className="h-8 font-medium"
                                        />
                                    </TableCell>
                                    <TableCell>
                                        <Input
                                            type="number"
                                            value={row.bs ?? ''}
                                            onChange={(e) => updateRow(row.id, 'bs', e.target.value)}
                                            className="h-8 text-right font-mono"
                                            placeholder="BS"
                                        />
                                    </TableCell>
                                    <TableCell className="text-right font-mono bg-muted/30">
                                        {row.calcIH?.toFixed(4) ?? '-'}
                                    </TableCell>
                                    <TableCell>
                                        <Input
                                            type="number"
                                            value={row.fs ?? ''}
                                            onChange={(e) => updateRow(row.id, 'fs', e.target.value)}
                                            className="h-8 text-right font-mono"
                                            placeholder="FS"
                                            disabled={row.isManualGH} // Start point (manual GH) typically has no FS
                                        />
                                    </TableCell>
                                    <TableCell className="text-right font-mono bg-muted/30">
                                        {row.isManualGH ? (
                                            <Input
                                                type="number"
                                                value={row.gh ?? ''}
                                                onChange={(e) => updateRow(row.id, 'gh', e.target.value)}
                                                className="h-8 text-right font-mono border-amber-500/50 bg-amber-50/50 dark:bg-amber-950/20"
                                            />
                                        ) : (
                                            row.gh?.toFixed(4) ?? '-'
                                        )}
                                    </TableCell>
                                    <TableCell>
                                        <Input
                                            value={row.note}
                                            onChange={(e) => updateRow(row.id, 'note', e.target.value)}
                                            className="h-8 text-xs text-muted-foreground"
                                        />
                                    </TableCell>
                                    <TableCell>
                                        <Button variant="ghost" size="icon" onClick={() => removeRow(row.id)} className="h-8 w-8 text-muted-foreground hover:text-destructive">
                                            <Trash2 className="h-3 w-3" />
                                        </Button>
                                    </TableCell>
                                </TableRow>
                            ))}
                            <TableRow>
                                <TableCell colSpan={8} className="text-center p-2">
                                    <Button variant="ghost" size="sm" onClick={addRow} className="w-full h-8 text-primary border border-dashed border-primary/30 hover:bg-primary/5">
                                        <Plus className="h-3 w-3 mr-2" /> 行を追加
                                    </Button>
                                </TableCell>
                            </TableRow>
                        </TableBody>
                    </Table>
                </div>

                <div className="p-2 text-xs text-muted-foreground border-t bg-muted/10">
                    <p>※開始点(No.1)は地盤高(GH)を直接入力できます。</p>
                    <p>※2行目以降は [前視(FS)] を入力すると [地盤高(GH)] が計算されます。</p>
                    <p>※[後視(BS)] を入力すると、次の [器械高(IH)] が計算されます。</p>
                </div>
            </CardContent>
        </Card>
    )
}
